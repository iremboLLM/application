"""
Summary:
This module provides a tool to check the application status and send the application document via email if applicable.

Classes:
    SendApplicationDocumentArgs: Pydantic model for application document sending arguments.

Functions:
    send_application_document: Checks the status, generates a PDF if needed, and sends it via email.

Returns:
    StructuredTool: A tool for handling the email delivery of application documents based on status.
"""

import os
from typing import Optional
from pydantic import BaseModel, Field
from supabase import create_client, Client
from langchain_core.tools import StructuredTool
from app.config.settings import Settings
from fpdf import FPDF
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Load application settings
app_setting = Settings()

# Initialize Supabase client
supabase_url = app_setting.SUPABASE_URL
supabase_key = app_setting.SUPABASE_KEY
supabase: Client = create_client(
    supabase_key=supabase_key,
    supabase_url=supabase_url,
)


def generate_pdf(data: dict, output_path: str) -> None:
    """
    Generates a detailed PDF document with the provided application data.

    Args:
        data (dict): The application data to include in the PDF.
        output_path (str): The file path where the PDF will be saved.
    """
    pdf = FPDF(orientation="P", unit="mm", format="A4")
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Title
    pdf.set_font("Arial", style="B", size=16)
    pdf.cell(0, 10, txt="Foreign Travel Application Document", ln=True, align="C")
    pdf.ln(10)

    # Applicant Information Section
    pdf.set_font("Arial", style="B", size=14)
    pdf.cell(0, 10, txt="Applicant Information", ln=True)
    pdf.ln(5)
    pdf.set_font("Arial", size=12)

    # User Details
    user_details = [
        ("First Name", data.get("Surname", "N/A")),
        ("Last Name", data.get("otherName", "N/A")),
        ("Passport Number", data.get("Passportnumber", "N/A")),
        ("Type of Travel Document", data.get("type_of_travel_document", "N/A")),
        ("Application Status", data.get("status", "N/A")),
    ]
    for label, value in user_details:
        pdf.cell(0, 10, txt=f"{label}: {value}", ln=True)
    pdf.ln(5)

    # Document Information Section
    pdf.set_font("Arial", style="B", size=14)
    pdf.cell(0, 10, txt="Document Information", ln=True)
    pdf.ln(5)
    pdf.set_font("Arial", size=12)

    document_details = [
        "This document is a formal acknowledgment of your application for a foreign travel document.",
        "It is essential to retain this document as proof of your application.",
        "Upon successful approval, the specified travel document will be issued.",
    ]
    for line in document_details:
        pdf.multi_cell(0, 10, txt=line)
    pdf.ln(5)

    # Footer Section
    pdf.set_y(-30)
    pdf.set_font("Arial", size=10)
    pdf.cell(
        0,
        10,
        txt="Generated by Irembo System. Contact support for any inquiries.",
        align="C",
    )

    # Save the PDF
    pdf.output(output_path)


def send_email(
    to_email: str, subject: str, body: str, attachment_path: Optional[str] = None
) -> str:
    """
    Sends an email with an optional attachment.

    Args:
        to_email (str): The recipient's email address.
        subject (str): The email subject.
        body (str): The email body.
        attachment_path (Optional[str]): The file path of the attachment.

    Returns:
        str: Success or error message.
    """
    try:
        sender_email = "dmurairimukongya@gmail.com"
        sender_password = "qpod uwzi mthc lslj"

        # Create the email
        msg = MIMEMultipart()
        msg["From"] = sender_email
        msg["To"] = to_email
        msg["Subject"] = subject
        msg.attach(MIMEText(body, "plain"))

        # Attach the file if provided
        if attachment_path:
            with open(attachment_path, "rb") as attachment:
                part = MIMEBase("application", "octet-stream")
                part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header(
                "Content-Disposition",
                f"attachment; filename={os.path.basename(attachment_path)}",
            )
            msg.attach(part)

        # Send the email
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, to_email, msg.as_string())
        server.quit()
        return "Email sent successfully."

    except Exception as e:
        print("about to send an email", e)
        return f"Error sending email: {str(e)}"


def send_application_document(billing_id: str, email: str) -> str:
    """
    Checks the application status and sends the document via email if applicable.

    Args:
        billing_id (str): The billing ID of the application.
        email (str): The recipient's email address.

    Returns:
        str: A message indicating the result of the operation.
    """
    if not billing_id:
        raise ValueError("billing_id must be provided.")
    if not email:
        raise ValueError("email must be provided.")

    try:
        # Fetch the application status
        data, error = (
            supabase.table("Foreign_Travel")
            .select("*")
            .eq("billing_id", billing_id)
            .execute()
        )

        if isinstance(error, tuple) and error[1] is not None:
            return f"Error fetching status: {error}"

        if data and len(data) > 0:
            application = data[1][0]
            print(application)
            status = application.get("status")

            # Handle different statuses
            if status in ["Approved", "Completed"]:
                # Generate and send the PDF
                output_path = "application_document.pdf"
                generate_pdf(application, output_path)
                subject = "Your Foreign Travel Application Document"
                body = "Please find attached your application document."
                return send_email(email, subject, body, attachment_path=output_path)

            elif status == "Pending":
                return "Your application is still pending. Please wait for further updates."

            elif status == "Rejected":
                return "Your application has been rejected. Please contact support for more information."

            elif status == "In Progress":
                return "Your application is in progress. Please check back later for updates."

            else:
                return "Unknown status. Please contact support for assistance."

        return "No application found for the provided billing ID."

    except Exception as e:
        print(e)
        return f"Exception: {str(e)}"


class SendApplicationDocumentArgs(BaseModel):
    """
    Pydantic model for sending application documents.

    Attributes:
        billing_id (str): The billing ID for the application.
        email (str): The recipient's email address.
    """

    billing_id: str = Field(..., description="The billing ID of the application.")
    email: str = Field(
        ..., description="The email address to send the application document."
    )


send_application_document_tool = StructuredTool(
    name="send_application_document_tool",
    description=(
        "This tool is used to send the application document via email."
        "Provide the following details: "
        "- `billing_id` (str): The billing ID of the application. "
        "- `email` (str): The recipient's email address. "
        "If the application status is 'Approved' or 'Completed', the document will be sent as a PDF attachment."
    ),
    func=send_application_document,
    args_schema=SendApplicationDocumentArgs,
)
